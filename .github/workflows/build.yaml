name: Smart Build and Release
on:
    push:
        branches:
            - master
            - main
    workflow_dispatch:

env:
    REPOSITORY: 'quay-its.epfl.ch'
    APP_NAME: 'wp-veritas'
    REGISTRY_PATH: 'quay-its.epfl.ch/svc0041/wp-veritas'

jobs:
    code-quality:
        name: Code Quality Check
        runs-on: ubuntu-24.04
        permissions:
            contents: read
            checks: write
            pull-requests: write
        outputs:
            eslint_passed: ${{ steps.eslint_check.outputs.passed }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: '18'
                  cache: 'npm'

            - name: Install dependencies
              run: |
                  echo "üì¶ Installing dependencies..."
                  npm ci --legacy-peer-deps

            - name: Run ESLint with annotations
              id: eslint_check
              run: |
                  echo "üîç Running ESLint analysis..."
                  
                  mkdir -p eslint-results
                  
                  set +e
                  
                  npm run lint -- --format json --output-file eslint-results/results.json
                  ESLINT_EXIT_CODE=$?
                  
                  echo "üìã ESLint Console Output:"
                  npm run lint -- --format stylish
                  
                  if [ -f "eslint-results/results.json" ]; then
                    echo "üìä Processing ESLint results for GitHub annotations..."
                    
                    GITHUB_WORKSPACE_RELATIVE=$(pwd)
                    
                    jq -r --arg workspace "$GITHUB_WORKSPACE_RELATIVE" '
                      .[] | 
                      select(.messages | length > 0) | 
                      .filePath as $file | 
                      (.filePath | sub($workspace + "/"; "")) as $relative_file |
                      .messages[] | 
                      if .severity == 2 then
                        "::error file=\($relative_file),line=\(.line),col=\(.column),endLine=\(.endLine // .line),endColumn=\(.endColumn // .column),title=ESLint Error (\(.ruleId // "unknown"))::\(.message)"
                      elif .severity == 1 then
                        "::warning file=\($relative_file),line=\(.line),col=\(.column),endLine=\(.endLine // .line),endColumn=\(.endColumn // .column),title=ESLint Warning (\(.ruleId // "unknown"))::\(.message)"
                      else
                        "::notice file=\($relative_file),line=\(.line),col=\(.column),title=ESLint Info (\(.ruleId // "unknown"))::\(.message)"
                      end
                    ' eslint-results/results.json
                    
                    ERROR_COUNT=$(jq '[.[] | .messages[] | select(.severity == 2)] | length' eslint-results/results.json)
                    WARNING_COUNT=$(jq '[.[] | .messages[] | select(.severity == 1)] | length' eslint-results/results.json)
                    TOTAL_FILES=$(jq '[.[] | select(.messages | length > 0)] | length' eslint-results/results.json)
                    
                    echo "üìà ESLint Summary:"
                    echo "  - Files with issues: $TOTAL_FILES"
                    echo "  - Errors: $ERROR_COUNT"
                    echo "  - Warnings: $WARNING_COUNT"
                    
                    if [ "$ERROR_COUNT" -gt 0 ]; then
                      echo "::error title=‚ùå ESLint Failed::Found $ERROR_COUNT errors and $WARNING_COUNT warnings across $TOTAL_FILES files"
                      echo "passed=false" >> $GITHUB_OUTPUT
                      
                    elif [ "$WARNING_COUNT" -gt 0 ]; then
                      echo "::warning title=‚ö†Ô∏è ESLint Warnings::Found $WARNING_COUNT warnings across $TOTAL_FILES files (no errors)"
                      echo "passed=true" >> $GITHUB_OUTPUT
                      
                    else
                      echo "::notice title=‚úÖ ESLint Success::No errors or warnings found! Code quality is excellent üéâ"
                      echo "passed=true" >> $GITHUB_OUTPUT
                    fi
                    
                  else
                    echo "::error title=üí• ESLint Configuration Error::Failed to generate ESLint results - check your ESLint configuration"
                    echo "passed=false" >> $GITHUB_OUTPUT
                  fi
                  
                  if [ "$ESLINT_EXIT_CODE" -eq 2 ]; then
                    echo "‚ùå ESLint found errors - failing the build"
                    exit 1
                  else
                    echo "‚úÖ ESLint completed - continuing with warnings if any"
                    exit 0
                  fi

            - name: Create ESLint Summary
              if: always()
              run: |
                  echo "## üîç ESLint Code Quality Report" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  
                  if [ -f "eslint-results/results.json" ]; then
                    ERROR_COUNT=$(jq '[.[] | .messages[] | select(.severity == 2)] | length' eslint-results/results.json)
                    WARNING_COUNT=$(jq '[.[] | .messages[] | select(.severity == 1)] | length' eslint-results/results.json)
                    TOTAL_FILES=$(jq '[.[] | select(.messages | length > 0)] | length' eslint-results/results.json)
                    CLEAN_FILES=$(jq '[.[] | select(.messages | length == 0)] | length' eslint-results/results.json)
                    
                    echo "### üìä Summary" >> $GITHUB_STEP_SUMMARY
                    echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
                    echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
                    echo "| üî¥ Errors | $ERROR_COUNT |" >> $GITHUB_STEP_SUMMARY
                    echo "| üü° Warnings | $WARNING_COUNT |" >> $GITHUB_STEP_SUMMARY
                    echo "| üìÅ Files with issues | $TOTAL_FILES |" >> $GITHUB_STEP_SUMMARY
                    echo "| ‚úÖ Clean files | $CLEAN_FILES |" >> $GITHUB_STEP_SUMMARY
                    echo "" >> $GITHUB_STEP_SUMMARY
                    
                    if [ "$ERROR_COUNT" -gt 0 ] || [ "$WARNING_COUNT" -gt 0 ]; then
                      echo "### üîç Most Common Issues" >> $GITHUB_STEP_SUMMARY
                      echo "| Rule | Occurrences | Type |" >> $GITHUB_STEP_SUMMARY
                      echo "|------|-------------|------|" >> $GITHUB_STEP_SUMMARY
                      jq -r '.[] | .messages[] | [(.ruleId // "no-rule"), .severity] | @tsv' eslint-results/results.json | \
                        sort | uniq -c | sort -nr | head -5 | \
                        while read count rule severity; do
                          if [ "$severity" = "2" ]; then
                            echo "| \`$rule\` | $count | üî¥ Error |" >> $GITHUB_STEP_SUMMARY
                          else
                            echo "| \`$rule\` | $count | üü° Warning |" >> $GITHUB_STEP_SUMMARY
                          fi
                        done
                      echo "" >> $GITHUB_STEP_SUMMARY
                      
                      if [ "$TOTAL_FILES" -gt 0 ]; then
                        echo "### üìÅ Files with Most Issues" >> $GITHUB_STEP_SUMMARY
                        echo "| File | Errors | Warnings |" >> $GITHUB_STEP_SUMMARY
                        echo "|------|--------|----------|" >> $GITHUB_STEP_SUMMARY
                        jq -r '.[] | select(.messages | length > 0) | [
                          (.filePath | sub("^.*/"; "")), 
                          (.messages | map(select(.severity == 2)) | length),
                          (.messages | map(select(.severity == 1)) | length)
                        ] | @tsv' eslint-results/results.json | \
                        sort -k2 -nr | head -5 | \
                        while IFS=$'\t' read file errors warnings; do
                          echo "| \`$file\` | $errors | $warnings |" >> $GITHUB_STEP_SUMMARY
                        done
                      fi
                    else
                      echo "### üéâ Excellent!" >> $GITHUB_STEP_SUMMARY
                      echo "No ESLint errors or warnings found. Your code quality is perfect! ‚ú®" >> $GITHUB_STEP_SUMMARY
                    fi
                  else
                    echo "### ‚ùå Error" >> $GITHUB_STEP_SUMMARY
                    echo "Could not process ESLint results. Check your configuration." >> $GITHUB_STEP_SUMMARY
                  fi

    detect-version:
        name: Detect Version
        needs: code-quality
        runs-on: ubuntu-24.04
        outputs:
            version: ${{ steps.get_version.outputs.version }}
            should_build: ${{ steps.check_version.outputs.should_build }}
            version_exists: ${{ steps.check_version.outputs.version_exists }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get Version from package.json
              id: get_version
              run: |
                  if [ ! -f "package.json" ]; then
                    echo "‚ùå package.json not found!"
                    exit 1
                  fi
                  
                  version=$(jq -r .version package.json)
                  if [ "$version" = "null" ] || [ -z "$version" ]; then
                    echo "‚ùå No version found in package.json!"
                    exit 1
                  fi
                  
                  echo "üì¶ Version from package.json: $version"
                  echo "version=$version" >> $GITHUB_OUTPUT

            - name: Set up Docker CLI
              uses: docker/setup-buildx-action@v3

            - name: Smart Version Check
              id: check_version
              run: |
                  VERSION="${{ steps.get_version.outputs.version }}"
                  echo "üîç Checking if version $VERSION exists on registry..."

                  if docker manifest inspect ${{ env.REGISTRY_PATH }}:$VERSION > /dev/null 2>&1; then
                    echo "version_exists=true" >> $GITHUB_OUTPUT
                    echo "üìã Version $VERSION exists on registry"
                    
                    LAST_TAG="v$VERSION"
                    if git rev-parse --verify "$LAST_TAG" >/dev/null 2>&1; then
                      echo "üè∑Ô∏è  Tag $LAST_TAG exists in git"
                      
                      COMMITS_SINCE_TAG=$(git rev-list ${LAST_TAG}..HEAD --count)
                      
                      if [ "$COMMITS_SINCE_TAG" -gt 0 ]; then
                        echo "üîÑ Found $COMMITS_SINCE_TAG commits since last tag - rebuild needed"
                        echo "should_build=true" >> $GITHUB_OUTPUT
                        echo "üí° Reason: Code changes detected since last build"
                      else
                        echo "‚úÖ No changes since last build - skipping"
                        echo "should_build=false" >> $GITHUB_OUTPUT
                      fi
                    else
                      echo "üîÑ No git tag found for version - rebuild needed"
                      echo "should_build=true" >> $GITHUB_OUTPUT
                      echo "üí° Reason: No git tag found (possible failed previous build)"
                    fi
                  else
                    echo "version_exists=false" >> $GITHUB_OUTPUT
                    echo "üÜï Version $VERSION doesn't exist - build needed"
                    echo "should_build=true" >> $GITHUB_OUTPUT
                    echo "üí° Reason: New version detected"
                  fi
                  
                  echo "üìä Summary:"
                  echo "  - Version: $VERSION"
                  echo "  - Exists on registry: $([ '${{ steps.check_version.outputs.version_exists }}' = 'true' ] && echo 'Yes' || echo 'No')"
                  echo "  - Should build: $([ '${{ steps.check_version.outputs.should_build }}' = 'true' ] && echo 'Yes' || echo 'No')"

    build-and-push:
        name: Build and Push
        needs: [code-quality, detect-version]
        if: needs.detect-version.outputs.should_build == 'true'
        runs-on: ubuntu-24.04
        permissions:
            contents: read
            packages: write
        outputs:
            version: ${{ needs.detect-version.outputs.version }}
            build_success: ${{ steps.build_result.outputs.success }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Build Info
              run: |
                  echo "üöÄ Starting build for version: ${{ needs.detect-version.outputs.version }}"
                  echo "üìÖ Build triggered at: $(date)"
                  echo "üåü Build reason: $([ '${{ needs.detect-version.outputs.version_exists }}' = 'true' ] && echo 'Rebuild after changes' || echo 'New version build')"

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Login to Docker Registry
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REPOSITORY }}
                  username: ${{ secrets.QUAY_ROBOT_USERNAME }}
                  password: ${{ secrets.QUAY_ROBOT_PASSWORD }}

            - name: Extract Docker metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.REGISTRY_PATH }}
                  tags: |
                      type=raw,value=latest
                      type=raw,value=${{ needs.detect-version.outputs.version }}

            - name: Build and push Docker image
              id: build_push
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  labels: ${{ steps.meta.outputs.labels }}
                  platforms: linux/amd64
                  cache-from: type=gha
                  cache-to: type=gha,mode=max

            - name: Verify Build Success
              id: build_result
              run: |
                  VERSION="${{ needs.detect-version.outputs.version }}"
                  echo "üîç Verifying build success..."
                  
                  echo "‚úÖ Build and push completed!"
                  echo "success=true" >> $GITHUB_OUTPUT
                  echo "üê≥ Image should be available at: ${{ env.REGISTRY_PATH }}:$VERSION"

            - name: Output Build Information
              run: |
                  echo "üìã Build Summary:"
                  echo "  - Version: ${{ needs.detect-version.outputs.version }}"
                  echo "  - Image: ${{ env.REGISTRY_PATH }}:${{ needs.detect-version.outputs.version }}"
                  echo "  - Tags: ${{ steps.meta.outputs.tags }}"
                  echo "  - Build ID: ${{ steps.build_push.outputs.imageid }}"
                  echo "  - Digest: ${{ steps.build_push.outputs.digest }}"

    create-release:
        name: Create Release
        needs: [code-quality, detect-version, build-and-push]
        if: needs.detect-version.outputs.should_build == 'true' && needs.build-and-push.outputs.build_success == 'true'
        runs-on: ubuntu-24.04
        permissions:
            contents: write
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Generate Smart Release Notes
              id: generate_notes
              run: |
                  VERSION="${{ needs.detect-version.outputs.version }}"
                  echo "üìù Generating release notes for version $VERSION"

                  LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
                  
                  echo "# üöÄ Release v$VERSION" > release_notes.txt
                  echo "" >> release_notes.txt
                  echo "**Released on:** $(date +'%Y-%m-%d %H:%M:%S UTC')" >> release_notes.txt
                  echo "**Docker Image:** \`${{ env.REGISTRY_PATH }}:$VERSION\`" >> release_notes.txt
                  echo "" >> release_notes.txt

                  if [ -z "$LAST_TAG" ]; then
                    echo "üìã No previous tag found, using last 10 commits"
                    echo "## üì¶ Initial Release" >> release_notes.txt
                    echo "" >> release_notes.txt
                    COMMITS=$(git log --oneline -10 --pretty=format:"%h %s")
                  else
                    echo "üìã Getting commits since last tag: $LAST_TAG"
                    COMMITS_COUNT=$(git rev-list ${LAST_TAG}..HEAD --count)
                    echo "## üîÑ Changes since $LAST_TAG ($COMMITS_COUNT commits)" >> release_notes.txt
                    echo "" >> release_notes.txt
                    COMMITS=$(git log --oneline ${LAST_TAG}..HEAD --pretty=format:"%h %s")
                  fi

                  echo "### ‚ú® Features" >> release_notes.txt
                  echo "$COMMITS" | grep -E "^[a-f0-9]+ (feat|feature|Feature|FEATURE)" | sed 's/^/- /' >> release_notes.txt || echo "- No new features" >> release_notes.txt
                  echo "" >> release_notes.txt
                  
                  echo "### üêõ Bug Fixes" >> release_notes.txt
                  echo "$COMMITS" | grep -E "^[a-f0-9]+ (fix|Fix|FIX)" | sed 's/^/- /' >> release_notes.txt || echo "- No bug fixes" >> release_notes.txt
                  echo "" >> release_notes.txt
                  
                  echo "### üîß Maintenance" >> release_notes.txt
                  echo "$COMMITS" | grep -E "^[a-f0-9]+ (chore|Chore|CHORE|refactor|style|perf)" | sed 's/^/- /' >> release_notes.txt || echo "- No maintenance changes" >> release_notes.txt
                  echo "" >> release_notes.txt
                  
                  echo "### üìö Documentation" >> release_notes.txt
                  echo "$COMMITS" | grep -E "^[a-f0-9]+ (docs|Docs|DOCS)" | sed 's/^/- /' >> release_notes.txt || echo "- No documentation changes" >> release_notes.txt
                  echo "" >> release_notes.txt

                  echo "### üîÑ Other Changes" >> release_notes.txt
                  echo "$COMMITS" | grep -vE "^[a-f0-9]+ (feat|feature|Feature|FEATURE|fix|Fix|FIX|chore|Chore|CHORE|docs|Docs|DOCS|refactor|style|perf)" | sed 's/^/- /' >> release_notes.txt || echo "- No other changes" >> release_notes.txt
                  echo "" >> release_notes.txt

                  echo "---" >> release_notes.txt
                  echo "**Technical Details:**" >> release_notes.txt
                  echo "- Build SHA: \`${{ github.sha }}\`" >> release_notes.txt
                  echo "- Workflow: [\`${{ github.workflow }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> release_notes.txt

                  echo "üìÑ Generated release notes:"
                  cat release_notes.txt

            - name: Create/Update Release
              run: |
                  VERSION="${{ needs.detect-version.outputs.version }}"
                  TAG_NAME="v$VERSION"
                  RELEASE_TITLE="v$VERSION"
                  
                  echo "üöÄ Creating/updating release $TAG_NAME"
                  
                  if gh release view "$TAG_NAME" >/dev/null 2>&1; then
                    echo "‚ÑπÔ∏è  Release $TAG_NAME already exists, updating..."
                    gh release edit "$TAG_NAME" \
                      --title "$RELEASE_TITLE" \
                      --notes-file release_notes.txt \
                      --latest
                    echo "‚úÖ Release updated successfully"
                  else
                    echo "üÜï Creating new release $TAG_NAME"
                    gh release create "$TAG_NAME" \
                      --title "$RELEASE_TITLE" \
                      --notes-file release_notes.txt \
                      --latest
                    echo "‚úÖ Release created successfully"
                  fi
                  
                  RELEASE_URL=$(gh release view "$TAG_NAME" --json url --jq .url)
                  echo "üîó Release URL: $RELEASE_URL"
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Output Release Information
              run: |
                  echo "üéâ Release Summary:"
                  echo "  - Version: v${{ needs.detect-version.outputs.version }}"
                  echo "  - Tag: v${{ needs.detect-version.outputs.version }}"
                  echo "  - Docker Image: ${{ env.REGISTRY_PATH }}:${{ needs.detect-version.outputs.version }}"

    cleanup:
        name: Cleanup Summary
        needs: [code-quality, detect-version, build-and-push, create-release]
        if: always() && needs.detect-version.outputs.should_build == 'true'
        runs-on: ubuntu-24.04
        steps:
            - name: Cleanup Summary
              run: |
                  echo "üßπ Cleanup Summary:"
                  echo "  - Code Quality: ${{ needs.code-quality.result }}"
                  echo "  - Build Status: ${{ needs.build-and-push.result }}"
                  echo "  - Release Status: ${{ needs.create-release.result }}"
                  
                  if [ "${{ needs.code-quality.result }}" = "success" ] && [ "${{ needs.build-and-push.result }}" = "success" ] && [ "${{ needs.create-release.result }}" = "success" ]; then
                    echo "‚úÖ Pipeline completed successfully!"
                  else
                    echo "‚ö†Ô∏è  Pipeline completed with issues - check previous jobs"
                    echo "    - ESLint: ${{ needs.code-quality.outputs.eslint_passed }}"
                  fi
