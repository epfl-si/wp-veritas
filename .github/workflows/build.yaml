name: Build and Release on Package Changes
on:
    push:
        branches:
            - main
        paths:
            - 'package.json'
            - 'package-lock.json'
            - 'Dockerfile'

env:
    REPOSITORY: 'quay-its.epfl.ch'
    APP_NAME: 'wp-veritas'
    REGISTRY_PATH: 'quay-its.epfl.ch/svc0041/wp-veritas'

jobs:
    detect-version:
        runs-on: ubuntu-24.04
        outputs:
            version: ${{ steps.get_version.outputs.version }}
            should_build: ${{ steps.check_version.outputs.should_build }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Get Version from package.json
              id: get_version
              run: |
                  version=$(jq -r .version package.json)
                  echo "Version from package.json: $version"
                  echo "version=$version" >> $GITHUB_OUTPUT

            - name: Set up Docker CLI
              uses: docker/setup-buildx-action@v3
              with:
                  install: true

            - name: Login to Registry
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REPOSITORY }}
                  username: ${{ secrets.QUAY_ROBOT_USERNAME }}
                  password: ${{ secrets.QUAY_ROBOT_PASSWORD }}

            - name: Check if version exists
              id: check_version
              run: |
                  VERSION="${{ steps.get_version.outputs.version }}"
                  echo "Checking if version $VERSION exists..."

                  if docker manifest inspect ${{ env.REGISTRY_PATH }}:$VERSION > /dev/null 2>&1; then
                    echo "Version $VERSION already exists, skipping build"
                    echo "should_build=false" >> $GITHUB_OUTPUT
                  else
                    echo "Version $VERSION doesn't exist, proceeding with build"
                    echo "should_build=true" >> $GITHUB_OUTPUT
                  fi

    build-and-push:
        needs: detect-version
        if: needs.detect-version.outputs.should_build == 'true'
        runs-on: ubuntu-24.04
        permissions:
            contents: read
            packages: write
        outputs:
            version: ${{ needs.detect-version.outputs.version }}
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3
              with:
                  install: true
                  platforms: linux/amd64

            - name: Login to Docker Registry
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REPOSITORY }}
                  username: ${{ secrets.QUAY_ROBOT_USERNAME }}
                  password: ${{ secrets.QUAY_ROBOT_PASSWORD }}

            - name: Extract Docker metadata
              id: meta
              uses: docker/metadata-action@v5
              with:
                  images: ${{ env.REGISTRY_PATH }}
                  tags: |
                      type=raw,value=latest
                      type=raw,value=${{ needs.detect-version.outputs.version }}

            - name: Build and push Docker image
              uses: docker/build-push-action@v5
              with:
                  context: .
                  file: ./Dockerfile
                  push: true
                  tags: ${{ steps.meta.outputs.tags }}
                  platforms: linux/amd64
                  cache-from: type=gha
                  cache-to: type=gha,mode=max

            - name: Output Build Information
              run: |
                  echo "Built and pushed image with version: ${{ needs.detect-version.outputs.version }}"
                  echo "Tags: ${{ steps.meta.outputs.tags }}"

    create-release:
        needs: [detect-version, build-and-push]
        if: needs.detect-version.outputs.should_build == 'true'
        runs-on: ubuntu-24.04
        permissions:
            contents: write
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Generate release notes from git log
              id: generate_notes
              run: |
                  VERSION="${{ needs.detect-version.outputs.version }}"

                  # Get the last tag to determine the range
                  LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

                  if [ -z "$LAST_TAG" ]; then
                    echo "No previous tag found, using last 10 commits"
                    COMMITS=$(git log --oneline -10 --pretty=format:"%h %s")
                  else
                    echo "Getting commits since last tag: $LAST_TAG"
                    COMMITS=$(git log --oneline ${LAST_TAG}..HEAD --pretty=format:"%h %s")
                  fi

                  # Format commits in the requested style
                  FORMATTED_NOTES=""
                  while IFS= read -r commit; do
                    if [ -n "$commit" ]; then
                      # Extract commit hash and message
                      HASH=$(echo "$commit" | cut -d' ' -f1)
                      MESSAGE=$(echo "$commit" | cut -d' ' -f2-)
                      
                      # Determine commit type based on message
                      if [[ "$MESSAGE" =~ ^(fix|Fix|FIX) ]]; then
                        TYPE="fix"
                      elif [[ "$MESSAGE" =~ ^(feat|feature|Feature|FEATURE) ]]; then
                        TYPE="feature"
                      elif [[ "$MESSAGE" =~ ^(chore|Chore|CHORE) ]]; then
                        TYPE="chore"
                      elif [[ "$MESSAGE" =~ ^(docs|Docs|DOCS) ]]; then
                        TYPE="docs"
                      else
                        TYPE="update"
                      fi
                      
                      # Clean up the message (remove type prefix if present)
                      CLEAN_MESSAGE=$(echo "$MESSAGE" | sed -E 's/^(fix|Fix|FIX|feat|feature|Feature|FEATURE|chore|Chore|CHORE|docs|Docs|DOCS):?\s*//')
                      
                      FORMATTED_NOTES="${FORMATTED_NOTES}${HASH} [${TYPE}] ${CLEAN_MESSAGE}\n"
                    fi
                  done <<< "$COMMITS"

                  # Remove trailing newline and save to file
                  echo -e "$FORMATTED_NOTES" | sed '$d' > release_notes.txt

                  echo "Generated release notes:"
                  cat release_notes.txt

            - name: Create Release
              uses: actions/create-release@v1
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  tag_name: v${{ needs.detect-version.outputs.version }}
                  release_name: Release v${{ needs.detect-version.outputs.version }}
                  body_path: release_notes.txt
                  draft: false
                  prerelease: false

            - name: Output Release Information
              run: |
                  echo "Created release for version: ${{ needs.detect-version.outputs.version }}"
                  echo "Docker image available at: ${{ env.REGISTRY_PATH }}:${{ needs.detect-version.outputs.version }}"
